#!/usr/bin/env lua

local color = require 'ansicolorsx'
local tabular = require 'tabular'
local argparse = require "argparse"
local lfs = require "lfs"
local inspect = require 'inspect'
local sha1 = require 'sha1'
local serpent = require 'serpent'
--local lanes = require 'lanes'.configure({ ["track_lanes"] = true})
local lanes = require 'lanes'.configure()
local maxthreads = 12
local sleep = require "socket".sleep
local lz = require "zlib"

local save_path = lfs.currentdir() .. "/.bld/hash.lua" 

-- change_extension("file.c", ".o") -> 'file.o'
local function change_extension(filename, new_ext)
    return string.gsub(filename, "(.*)(%..*)$", "%1" .. new_ext)
end

--[[
print(change_extension("file.c", ".o"))
print(change_extension("file.c++", ".obj"))
print(change_extension("file.", ".o"))
--]]

local function error(...)
    local args = {...}
    local s = "%{red}"
    for i = 1, #args do
        s = s .. args[i]
    end
    print(color(s))
end

local function panic(...)
    error(...)
    os.exit(1)
end

local function build_object(item, cfg, args)
    --print()
    --print(tabular(item, {}, true))
    --print()
    --assert(CFG, "bld.lua not load properly")
    
    local includes = table.concat(cfg.includes, ' ')
    local flags = table.concat(cfg.flags, ' ')

    print(inspect(args))
    os.exit()

    --print('item', inspect(item))
    local obj_name = change_extension(item[2], ".o")
    local cmd = string.format(
        "emcc -c %s/%s -o wasm_obj/%s %s %s",
        item[1], item[2], obj_name, flags, includes
    )

    if args.verbose then
        local cmd_table = {
            includes = cfg.includes,
            flags = cfg.flags,
            cc = 'emcc',
            dir_name = item[1],
            file_name = item[2],
            obj_name = obj_name,
        }
        print(tabular(cmd_table, {}, true))
    end

    print(color("%{cyan}" .. cmd))

    local stream = io.popen(cmd, "r")
    local output = stream:read("a")
    --print(output)
    return { { stream:close() }, output = output }
end

local function find_files(dirname, file_pattern)
    local files_list= {}
    for file in lfs.dir(dirname) do
        if string.match(file, file_pattern) then
            table.insert(files_list, { dirname , file})
        end
    end
    return files_list
end

local function read_hashes()
    print('save_path', save_path)
    local data
    local ok, errmsg = pcall(function()
        local file = io.open(save_path, "r")
        data = file:read("*a")
        local inflator = lz.inflate()
        data = inflator(data, 'finish')
        data = load(data)()
    end)
    if not ok then
        error('read_hashes:', errmsg)
        data = {}
    end
    return data
end

local function write_hashes(hashes_list)
    --print('hashes_list', inspect(hashes_list))
    --print('save_path', save_path)
    local ok, errmsg = pcall(function()
        local data = serpent.dump(hashes_list)
        local deflator = lz.deflate()
        local data = deflator(data, 'finish')
        local file = io.open(save_path, "w")
        file:write(data)
    end)
    if not ok then
        panic('write_hashes', errmsg)
    end
end

local function check_bld_dir()
    local ok, errmg = pcall(function()
        lfs.mkdir(".bld")
    end)
end

local function dohash(name)
    local hash
    local ok, errmsg = pcall(function()
        local content = io.open(name[1] .. '/' .. name[2], "r"):read("*a")
        hash = sha1.sha1(content)
    end)
    if not ok then 
        error("dohash: error ", errmsg)
    end
    return hash
end

local function wait_threads(threads)
    local waiting = true
    while waiting do
        waiting = false
        for _, thread in pairs(threads) do
            if thread.status == 'running' then
                waiting = true
                break
            end
        end
        sleep(0.01)
    end
end

local function get_hashes(files_list)
    local start_t = os.time()
    local hashes = {}
    local threads = {}
    local dohash_func = lanes.gen("*", dohash)
    local bundle_num = 0
    local used_threads = 0

    for _, name in pairs(files_list) do
        if used_threads <= maxthreads then
            threads[#threads + 1] = dohash_func(name)
            used_threads= used_threads+ 1
        else
            wait_threads(threads)
            for _, thread in pairs(threads) do
                local hash, errcode = thread:join()
                if hash then
                    table.insert(hashes, { 
                        name[1], name[2], hash
                    })
                else
                    error('thread:join', errcode)
                end
            end
            used_threads = 0
            bundle_num = bundle_num + 1
        end
    end
    local end_t = os.time()
    --print('bundles', bundle_num)
    print("get_hashes: elapsed", end_t - start_t)
    return hashes
end

local function join_compilers(threads)
    for _, thread in pairs(threads) do
        local ret, errcode = thread:join()
        --if ret[1][1] == true then
        --end
        if ret then
            print(tabular(ret))
        end
        if errcode then
            print(tabular(errcode))
        end
    end
end

local function build_files(files_list, cfg, args)
    local start_t = os.time()
    local threads = {}
    local compiler_func = lanes.gen("*", build_object)

    local bundle_num = 0
    local used_threads = 0
    for _, file_name in pairs(files_list) do
        if used_threads <= maxthreads then
            threads[#threads + 1] = compiler_func(file_name, cfg, args)
            used_threads= used_threads+ 1
        else
            print('bundle_num', bundle_num)
            wait_threads(threads)
            join_compilers(threads)
            threads = {}
            bundle_num = bundle_num + 1
            used_threads = 0
        end
    end

    print('bundles', bundle_num)
 
    local end_t = os.time()
    print('building time', end_t - start_t)
end

local function deepcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[deepcopy(orig_key)] = deepcopy(orig_value)
        end
        setmetatable(copy, deepcopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

local function trim(s)
   return (s:gsub("^%s*(.-)%s*$", "%1"))
end

local function tabrim(s)
   return (s:gsub("^\t*(.-)\t*$", "%1"))
end

local function string2table(str)
    --print(type(str))
    assert(type(str) == 'string')
    local res = {}
    for s in string.gmatch(str, "([^\r\n]+)") do
        local a = trim(s)
        a = tabrim(a)
        if #a > 0 then
            table.insert(res, a)
        end
    end
    return res
end

local function load_cfg(verbose)
    local cfg
    local ok, errmsg = pcall(function()
        cfg = loadfile(lfs.currentdir() .. "/" .. "bld.lua")()
    end)
    if not ok then
        panic('load_cfg:', errmsg)
    end

    for k, v in pairs(cfg) do
        if type(v) == 'string' then
            cfg[k] = string2table(cfg[k])
        end
    end

    if verbose then
        print(tabular(cfg, {}, true))
    end

    return cfg
end

local function make_hashes_dict(hashes_arr)
    local dict = {}
    if hashes_arr then
        for k, v in pairs(hashes_arr) do
            dict[v.dir_name .. "/" .. v.file_name] = {
                ref = v,
                hash = v.hash,
            }
        end
    end
    return dict
end

local function get_hashes_difference(old_hashes, new_hashes)
    if not old then
        return new_hashes
    end

    local old_tmp = make_hashes_dict(old_hashes)
    local new_tmp = make_hashes_dict(new_hashes)

    --print('old_tmp', inspect(old_tmp))
    --print('new_tmp', inspect(new_tmp))

    local diff = {}

    for new_path, new_hash in pairs(new_tmp) do
        local item = old_tmp[new_path]
        --print('item', item)
        if not item then
            table.insert(diff, new_hash.ref)
        else
            if item.hash ~= new_hash.hash then
                table.insert(diff, new_hash.ref)
            end
        end
    end
    return diff
end

local function final_command(cfg, args)
    --print('final_command')
    if not cfg.final_command then
        return
    end

    if args.verbose then
        local final_command_table = {
            final_command = cfg.final_command,
            includes = cfg.includes,
            flags = cfg.flags,
            libs = cfg.libs,
            libs_path = cfg.libs_path
        }
        print(tabular(final_command_table, {}, true))
    end

    local final_command = table.concat(cfg.final_command, " ")
    local includes = table.concat(cfg.includes, ' ')
    local flags = table.concat(cfg.flags, ' ')
    local libs = table.concat(cfg.libs, ' ')
    local libs_path = table.concat(cfg.libs_path, " ")

    final_command = final_command .. ' ' ..
                    includes .. ' ' .. 
                    libs_path .. ' ' ..
                    libs .. ' ' .. 
                    flags

    print('final_command', final_command)
    local stream = io.popen(final_command, "r")
    print(stream:read("*a"))
end

local function link(files_list, cfg)
    print(tabular(files_list, {}, true))
    local object_files = {}
    for k, v in pairs(files_list) do
        local obj_name = cfg.obj_dir[1] .. "/" .. change_extension(v[2], ".o")
        table.insert(object_files, obj_name)
    end
    local object_files_str = table.concat(object_files, " ")
    local cmd = string.gsub(cfg.link[1], "{OBJECT_FILES}", object_files_str)
    local stream = io.popen(cmd, "r")
    print(stream:read("*a"))
end

local function check_object_files(files_list, cfg)
    local dirname = cfg.obj_dir[1]

    local object_pattern = ".*%.o"
    local object_files = {}
    for file in lfs.dir(dirname) do
        if string.match(file, object_pattern) then
            object_files[file] = true
        end
    end

    local files_dict = {}
    for k, v in pairs(files_list) do
        files_dict[change_extension(v[2], ".o")] = v
    end

    local tobuild_list= {}
    for k, v in pairs(files_dict) do
        if not object_files[k] then
            tobuild_list[#tobuild_list + 1] = v
        end
    end

    --print('files_dict', inspect(files_dict))
    --print("object_files", inspect(object_files))
    --print('tobuild_list', inspect(tobuild_list))

    return tobuild_list
end

local function union(list_a, list_b)
    local sum = {}
    for k, v in pairs(list_a) do
        sum[k] = v
    end
    for k, v in pairs(list_b) do
        sum[k] = v
    end
    return sum
end

local function clean(cfg)
    if not cfg.obj_dir then
        return
    end
    local cmd = "rm " .. lfs.currentdir() .. '/' .. cfg.obj_dir[1] .. "/*.o"
    --print('cmd', cmd)
    local stream = io.popen(cmd, "r")
    print(stream:read("*a"))
end

local function main()
    local parser = argparse()
    parser:flag("-v --verbose", "print build info")
    parser:add_complete_command()
    parser:require_command(false)
    parser:command "clean"
    local arguments = parser:parse()

    local cfg = load_cfg(arguments.verbose)

    if arguments.clean then
        clean(cfg)
    else

        check_bld_dir()
        local old_hashes = read_hashes()

        local files_list = find_files(cfg.dir_name[1], cfg.pattern[1])
        print(tabular(files_list, {}, true))
        local new_hashes = get_hashes(files_list)
        local non_existing_objects = check_object_files(files_list, cfg)
        --print('non_existing_objects', inspect(non_existing_objects))
        local difference = get_hashes_difference(old_hashes, new_hashes)
        local to_build = union(difference, non_existing_objects)
        --print('difference', inspect(difference))
        print(tabular(to_build, {}, true))
        --print(inspect(arguments))
        --os.exit()
        build_files(to_build, cfg, arguments)
        write_hashes(new_hashes)
        link(files_list, cfg)
        final_command(cfg, arguments)
        --]]
        --print("files_list", inspect(files_list))
        --print("old_hashes", inspect(old_hashes))
        --print('new_hashes', inspect(new_hashes))
    end
end

main()

--[[
local function threaded_func(arg)
    local inspect = require 'inspect'
    return "|" .. inspect(arg)
end

local f = lanes.gen("*", threaded_func)({1, 2, 3})
local ret, errcode = f:join()

print(ret, code)
--local res = f({1, 2, 3})
print(inspect(res))
--]]
